{{!< default}}

{{!-- Include common map styles --}}
{{> map-styles}}

{{!-- Debug information to check post data structure --}}
<div class="debug-info" style="display: none;">
    Post exists: {{#if post}}Yes{{else}}No{{/if}}<br>
    Visibility: {{post.visibility}}<br>
    Member exists: {{#if @member}}Yes{{else}}No{{/if}}<br>
    Member paid: {{#if @member.paid}}Yes{{else}}No{{/if}}<br>
    Embed mode: <span id="debug-embed-mode">No</span><br>
    URL: {{url}}<br>
    Content length: {{content.length}}
</div>

{{#post}}
    {{!-- Store the raw post content for embed mode --}}
    <div id="raw-content" style="display: none;">{{{html}}}</div>
    
    {{!-- Check for embed mode first --}}
    <script>
        // Check for embed parameter in URL
        const urlParams = new URLSearchParams(window.location.search);
        const embedParam = urlParams.get('embed');
        const isEmbedMode = (embedParam === 'true');
        
        // Store in window for access in other scripts
        window.isEmbedMode = isEmbedMode;
        window.postVisibility = "{{visibility}}";
        window.isMember = {{#if @member}}true{{else}}false{{/if}};
        window.isPaidMember = {{#if @member.paid}}true{{else}}false{{/if}};
        
        // Add embed-mode class if needed
        if (isEmbedMode) {
            document.body.classList.add('embed-mode');
            // Update debug info
            const debugEmbedMode = document.getElementById('debug-embed-mode');
            if (debugEmbedMode) {
                debugEmbedMode.textContent = 'Yes';
            }
            
            // Hide header and footer in embed mode
            document.addEventListener('DOMContentLoaded', function() {
                const header = document.querySelector('.gh-head');
                const footer = document.querySelector('.gh-foot');
                if (header) header.style.display = 'none';
                if (footer) footer.style.display = 'none';
            });
        }
    </script>

    {{!-- Check URL parameters for embed mode --}}
    {{#if (match @url "embed=true")}}
        {{!-- In embed mode, always show the map regardless of visibility --}}
        <article class="post-full leaflet-map-template map-template">
            <div id="map" style="height: 100vh;"></div>
            <div class="map-data-container" style="display: none;">{{{html}}}</div>
        </article>
    {{else}}
        {{!-- Not in embed mode, check visibility --}}
        {{#has visibility="public"}}
            <article class="post-full leaflet-map-template map-template">
                <div id="map" style="height: 100vh;"></div>
                <div class="map-data-container" style="display: none;">{{{content}}}</div>
            </article>
        {{else}}
            {{#has visibility="members"}}
                {{#if @member}}
                    <article class="post-full leaflet-map-template map-template">
                        <div id="map" style="height: 100vh;"></div>
                        <div class="map-data-container" style="display: none;">{{{content}}}</div>
                    </article>
                {{else}}
                    <div class="map-access-message">
                        <h2>This map is available to members</h2>
                        <p>Sign up or log in to view this map.</p>
                        <div class="map-access-cta">
                            <a href="#/portal/signup" class="map-signup-button">Sign up now</a>
                            <a href="#/portal/signin" class="map-signin-button">Log in</a>
                        </div>
                    </div>
                {{/if}}
            {{else}}
                {{#has visibility="paid"}}
                    {{#if @member.paid}}
                        <article class="post-full leaflet-map-template map-template">
                            <div id="map" style="height: 100vh;"></div>
                            <div class="map-data-container" style="display: none;">{{{content}}}</div>
                        </article>
                    {{else}}
                        <div class="map-access-message">
                            <h2>This map is available to paid members</h2>
                            <p>Upgrade your membership to view this map.</p>
                            <div class="map-access-cta">
                                {{#if @member}}
                                    <a href="#/portal/account/plans" class="map-upgrade-button">Upgrade now</a>
                                {{else}}
                                    <a href="#/portal/signup" class="map-signup-button">Sign up now</a>
                                    <a href="#/portal/signin" class="map-signin-button">Log in</a>
                                {{/if}}
                            </div>
                        </div>
                    {{/if}}
                {{else}}
                    <article class="post-full leaflet-map-template map-template">
                        <div id="map" style="height: 100vh;"></div>
                        <div class="map-data-container" style="display: none;">{{{content}}}</div>
                    </article>
                {{/has}}
            {{/has}}
        {{/has}}
    {{/if}}

<link
  rel="stylesheet"
  href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
/>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="{{asset "js/leaflet-custom-icons.js"}}"></script>

<script>
document.addEventListener("DOMContentLoaded", function () {
  console.log("DOM loaded, initializing map");
  console.log("Embed mode:", window.isEmbedMode);
  console.log("Post visibility:", window.postVisibility);
  console.log("Member status:", window.isMember, "Paid member:", window.isPaidMember);
  
  // Only initialize the map if the map element exists
  const mapElement = document.getElementById('map');
  if (!mapElement) {
    console.warn("No map element found");
    return;
  }

  const imageUrl = "{{feature_image}}";
  const videoUrl = "/assets/images/overlays/Daytime_Clouds_Squar_One.webm"

  const img = new Image();
  img.onload = function () {
    const w = this.naturalWidth;
    const h = this.naturalHeight;

    // Full image bounds
    const imageBounds = [[0, 0], [h, w]];

    // Create the map
    const map = L.map("map", {
      crs: L.CRS.Simple,
      preferCanvas: true,
      minZoom: -5,
      maxZoom: 2,
      zoomSnap: 0,
      zoomDelta: 0.25,
      maxBounds: imageBounds
    });

    // Add the image
    L.imageOverlay(imageUrl, imageBounds).addTo(map);
    
    // Add video overlay (ie. clouds)
    const videoOverlay = L.videoOverlay(videoUrl, imageBounds, {
      autoplay: true,
      loop: true,
      muted: true,
      opacity: 0.6,
      keepAspectRatio: false
    }).addTo(map);
    
    // Function to disable picture-in-picture
    function disablePiP() {
      try {
        const videoElement = videoOverlay.getElement();
        if (videoElement) {
          // Set the attribute
          videoElement.disablePictureInPicture = true;
          
          // Also add the attribute directly to the DOM element
          videoElement.setAttribute('disablePictureInPicture', '');
        }
      } catch (e) {
        console.error("Error disabling picture-in-picture:", e);
      }
    }
    
    // Try immediately
    disablePiP();
    
    // Also try after a short delay to ensure the video is loaded
    setTimeout(disablePiP, 100);
    
    // Get viewport height and calculate scale to fit height
    const viewportHeight = window.innerHeight;
    const scale = viewportHeight / h;
    const zoom = Math.log2(scale);

    // Clamp to allowed zooms
    const clampedZoom = Math.max(map.getMinZoom(), Math.min(map.getMaxZoom(), zoom));

    map.setView([h / 2, w / 2], clampedZoom);
    
    // Process map data from post content
    processMapData(map, h, w);
  };

  img.src = imageUrl;
  
  /**
   * Process map data from post content
   * Looks for JSON data in the post content and adds markers and other overlays to the map
   */
  function processMapData(map, imageHeight, imageWidth) {
    // First try to get the content from the map-data-container
    const mapDataContainer = document.querySelector('.map-data-container');
    // Also try the raw-content div as a backup
    const rawContent = document.getElementById('raw-content');
    
    let contentElement = mapDataContainer || rawContent;
    
    if (!contentElement) {
      console.warn('No content container found');
      return;
    }
    
    console.log("Using content from:", contentElement.id || 'map-data-container');
    
    try {
      // Get the content as text
      const contentText = contentElement.innerHTML;
      console.log("Content length:", contentText.length);
      console.log("Content preview:", contentText.substring(0, 200) + "...");
      
      // Try to find JSON data in the content
      // First, look for JSON objects with markers array
      const markerJsonRegex = /\{\s*"markers"\s*:\s*\[[\s\S]*?\]\s*\}/g;
      const markerJsonMatches = contentText.match(markerJsonRegex);
      
      if (markerJsonMatches && markerJsonMatches.length > 0) {
        console.log("Found potential marker JSON data:", markerJsonMatches.length);
        
        // Try to parse each match as JSON
        markerJsonMatches.forEach((jsonString, index) => {
          try {
            const mapData = JSON.parse(jsonString);
            console.log(`Successfully parsed marker JSON match #${index}:`, mapData);
            
            // Process the map data
            processMapDataObject(map, mapData);
          } catch (e) {
            console.log(`Failed to parse marker JSON match #${index}:`, e);
          }
        });
      } else {
        console.warn("No marker JSON data found, trying general JSON pattern");
        
        // Try a more general JSON regex
        const generalJsonRegex = /\{[\s\S]*?\}/g;
        const generalJsonMatches = contentText.match(generalJsonRegex);
        
        if (generalJsonMatches && generalJsonMatches.length > 0) {
          console.log("Found potential general JSON data:", generalJsonMatches.length);
          
          // Try to parse each match as JSON
          generalJsonMatches.forEach((jsonString, index) => {
            try {
              const mapData = JSON.parse(jsonString);
              
              // Check if this looks like map data
              if (mapData.markers || mapData.polylines || mapData.polygons || mapData.circles || mapData.rectangles || mapData.view) {
                console.log(`Successfully parsed general JSON match #${index} as map data:`, mapData);
                
                // Process the map data
                processMapDataObject(map, mapData);
              }
            } catch (e) {
              // Ignore parsing errors for general JSON
            }
          });
        } else {
          console.warn("No JSON data found in content");
          
          // Try to extract content from pre tags
          const preElements = contentElement.querySelectorAll('pre');
          console.log("Found pre elements:", preElements.length);
          
          if (preElements.length > 0) {
            preElements.forEach((pre, index) => {
              try {
                const content = pre.textContent.trim();
                console.log(`Pre element #${index} content:`, content.substring(0, 100) + "...");
                
                if (content.startsWith('{') && content.endsWith('}')) {
                  const mapData = JSON.parse(content);
                  console.log(`Successfully parsed pre element #${index}:`, mapData);
                  
                  // Process the map data
                  processMapDataObject(map, mapData);
                }
              } catch (e) {
                console.log(`Failed to parse pre element #${index}:`, e);
              }
            });
          }
        }
      }
    } catch (e) {
      console.error('Error processing map data:', e);
    }
  }
  
  /**
   * Process a map data object and add its elements to the map
   */
  function processMapDataObject(map, mapData) {
    if (!mapData) return;
    
    // Process markers
    if (mapData.markers && Array.isArray(mapData.markers)) {
      console.log("Processing markers:", mapData.markers.length);
      mapData.markers.forEach(marker => {
        if (marker.position && Array.isArray(marker.position) && marker.position.length === 2) {
          // Convert coordinates to match the image coordinate system if needed
          const y = marker.position[0];
          const x = marker.position[1];
          
          let markerOptions = {};
          
          // Apply custom icon if specified
          if (marker.icon) {
            markerOptions.icon = L.icon(marker.icon);
          } else if (marker.iconType && window.customIcons && window.customIcons[marker.iconType]) {
            // Use predefined custom icon if iconType is specified
            markerOptions.icon = window.customIcons[marker.iconType];
          }
          
          // Create the marker
          const m = L.marker([y, x], markerOptions).addTo(map);
          
          // Add popup if specified
          if (marker.popup) {
            m.bindPopup(marker.popup);
          }
          
          // Add tooltip if specified
          if (marker.tooltip) {
            m.bindTooltip(marker.tooltip);
          }
        }
      });
    }
    
    // Process polylines
    if (mapData.polylines && Array.isArray(mapData.polylines)) {
      mapData.polylines.forEach(polyline => {
        if (polyline.points && Array.isArray(polyline.points)) {
          const options = polyline.options || {};
          L.polyline(polyline.points, options).addTo(map);
        }
      });
    }
    
    // Process polygons
    if (mapData.polygons && Array.isArray(mapData.polygons)) {
      mapData.polygons.forEach(polygon => {
        if (polygon.points && Array.isArray(polygon.points)) {
          const options = polygon.options || {};
          L.polygon(polygon.points, options).addTo(map);
        }
      });
    }
    
    // Process circles
    if (mapData.circles && Array.isArray(mapData.circles)) {
      mapData.circles.forEach(circle => {
        if (circle.center && Array.isArray(circle.center) && circle.center.length === 2 && circle.radius) {
          const options = circle.options || {};
          L.circle(circle.center, { radius: circle.radius, ...options }).addTo(map);
        }
      });
    }
    
    // Process rectangles
    if (mapData.rectangles && Array.isArray(mapData.rectangles)) {
      mapData.rectangles.forEach(rectangle => {
        if (rectangle.bounds && Array.isArray(rectangle.bounds) && rectangle.bounds.length === 2) {
          const options = rectangle.options || {};
          L.rectangle(rectangle.bounds, options).addTo(map);
        }
      });
    }
    
    // Process custom view settings
    if (mapData.view) {
      if (mapData.view.center && Array.isArray(mapData.view.center) && mapData.view.center.length === 2) {
        const zoom = mapData.view.zoom !== undefined ? mapData.view.zoom : map.getZoom();
        map.setView(mapData.view.center, zoom);
      }
    }
  }
});

// Enable debug info with a query parameter
if (window.location.search.includes('debug=true')) {
  document.querySelector('.debug-info').style.display = 'block';
}
</script>
{{/post}}

