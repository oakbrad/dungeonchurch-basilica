{{!< default}}

<style>
    /* Remove site footer and content */
    .site-footer,
    .content-title,
    .post-full-footer,
    .post-content {
        display: none !important;
    }
    /* Match map style to Ghost */
    #map {
        background-color: var(--color-darkmode);
        flex: 1 !important;
        height: calc(100vh - 88px) !important;/* Adjust header height if needed */
        width: 100% !important;
    }

    /* Leaflet tooltip styling */
    .leaflet-tooltip {
        background-color: rgba(21, 23, 26, 0.9) !important;
        color: #fff !important;
        font-family: var(--font-sans) !important;
        font-size: 2em !important;
        padding: 8px 12px !important;
        border: 1px solid rgba(255, 255, 255, 0.5) !important;
        border-radius: 4px !important;
        box-shadow: 0 0 15px rgba(0, 0, 0, 0.4) !important;
        backdrop-filter: blur(8px) !important;
        -webkit-backdrop-filter: blur(8px) !important;
        width: 400px !important;
        white-space: normal !important;
    }
    
    .leaflet-tooltip b {
      text-transform: uppercase !important;
      font-weight: bolder !important;
      color: var(--ghost-accent-color) !important;
    }
    /* Tooltip arrow styling */
    .leaflet-tooltip-top:before,
    .leaflet-tooltip-bottom:before,
    .leaflet-tooltip-left:before,
    .leaflet-tooltip-right:before {
        border-color: transparent;
    }
    
    .leaflet-tooltip-bottom:before {
        border-bottom-color: var(--ghost-accent-color) !important;
    }
    
    .leaflet-tooltip-top:before {
        border-top-color: var(--ghost-accent-color) !important;
    }
    
    .leaflet-tooltip-left:before {
        border-left-color: var(--ghost-accent-color) !important;
    }
    
    .leaflet-tooltip-right:before {
        border-right-color: var(--ghost-accent-color) !important;
    }

    /* Leaflet popup styling */
    .leaflet-popup-content-wrapper {
        background-color: rgba(21, 23, 26, 0.9)  !important;
        border-left: 4px solid var(--ghost-accent-color)  !important;
        color: #fff  !important;
        font-family: var(--font-sans)  !important;
        border-radius: 4px  !important;
        box-shadow: 0 0 20px rgba(0, 0, 0, 0.5)  !important;
        backdrop-filter: blur(20px)  !important;
        -webkit-backdrop-filter: blur(20px)  !important;
    }

    .leaflet-popup-content {
        color: #fff !important;
        margin: 12px  !important;
    }

    /* Styling for access message */
    .map-access-message {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100vh;
        text-align: center;
        padding: 2rem;
        background: linear-gradient(to bottom right, #3f3f3f, var(--color-darkmode));
        color: #fff;
    }

    .map-access-message h2 {
        font-size: 2.5rem;
        margin-bottom: 1rem;
        color: #fff;
    }

    .map-access-message p {
        font-size: 1.2rem;
        margin-bottom: 2rem;
        max-width: 600px;
    }

    .map-access-cta {
        display: flex;
        gap: 1rem;
        margin-top: 1rem;
    }

    .map-signup-button,
    .map-signin-button,
    .map-upgrade-button {
        display: inline-block;
        padding: 0.8rem 1.5rem;
        border-radius: 4px;
        font-weight: 600;
        text-decoration: none;
        transition: all 0.2s ease;
    }

    .map-signup-button,
    .map-upgrade-button {
        background-color: var(--ghost-accent-color);
        color: #fff;
    }

    .map-signin-button {
        background-color: transparent;
        border: 1px solid #fff;
        color: #fff;
    }

    .map-signup-button:hover,
    .map-upgrade-button:hover {
        opacity: 0.9;
        transform: translateY(-2px);
    }

    .map-signin-button:hover {
        background-color: rgba(255, 255, 255, 0.1);
        transform: translateY(-2px);
    }

    /* Mobile adjustments */
    @media only screen and (max-width: 768px) {
        .map-access-message h2 {
            font-size: 1.8rem;
        }

        .map-access-message p {
            font-size: 1rem;
        }

        .map-access-cta {
            flex-direction: column;
        }
        
        /* Mobile tooltip adjustments */
        .leaflet-tooltip {
            width: auto !important;
            padding: 6px 10px !important;
            white-space: normal !important;
        }
    }

    /* Map data container - hidden by default */
    .map-data-container {
        display: none;
    }
</style>

{{!-- Debug information to check post data structure --}}
<div class="debug-info" style="display: none;">
    <pre>{{json post}}</pre>
</div>

{{!-- Map container --}}
<div id="map"></div>

{{!-- Hidden container for map data --}}
<div class="map-data-container">{{content}}</div>

<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Check if user has access to the map
        const hasAccess = true; // Replace with your access check logic
        
        if (!hasAccess) {
            showAccessMessage();
            return;
        }
        
        // Initialize map
        initializeMap();
    });
    
    function showAccessMessage() {
        // Create access message container
        const mapContainer = document.getElementById('map');
        const accessMessage = document.createElement('div');
        accessMessage.className = 'map-access-message';
        
        // Determine message based on user status (member, free, non-member)
        const isMember = false; // Replace with your member check
        const isFree = false; // Replace with your free tier check
        
        let title, message, ctaButtons;
        
        if (isMember && !isFree) {
            // Paid member who needs to upgrade
            title = 'Upgrade Required';
            message = 'This map is available to premium members only. Please upgrade your membership to access this exclusive content.';
            ctaButtons = `
                <div class="map-access-cta">
                    <a href="/upgrade/" class="map-upgrade-button">Upgrade Membership</a>
                </div>
            `;
        } else if (isMember) {
            // Free member who needs to upgrade
            title = 'Upgrade Required';
            message = 'This map is available to premium members only. Please upgrade your membership to access this exclusive content.';
            ctaButtons = `
                <div class="map-access-cta">
                    <a href="/upgrade/" class="map-upgrade-button">Upgrade Membership</a>
                </div>
            `;
        } else {
            // Non-member who needs to sign up
            title = 'Members Only Content';
            message = 'This interactive map is available exclusively to our members. Sign up for free or log in to access this content.';
            ctaButtons = `
                <div class="map-access-cta">
                    <a href="/signup/" class="map-signup-button">Sign Up Free</a>
                    <a href="/signin/" class="map-signin-button">Sign In</a>
                </div>
            `;
        }
        
        // Set content
        accessMessage.innerHTML = `
            <h2>${title}</h2>
            <p>${message}</p>
            ${ctaButtons}
        `;
        
        // Replace map with access message
        mapContainer.parentNode.replaceChild(accessMessage, mapContainer);
    }
    
    function initializeMap() {
        // Parse map data from hidden container
        const mapDataContainer = document.querySelector('.map-data-container');
        let mapData;
        
        try {
            // Try to parse as JSON first
            mapData = JSON.parse(mapDataContainer.textContent.trim());
        } catch (e) {
            // If not valid JSON, try to extract from HTML content
            const mapDataMatch = mapDataContainer.textContent.match(/```json\s*([\s\S]*?)\s*```/);
            if (mapDataMatch && mapDataMatch[1]) {
                try {
                    mapData = JSON.parse(mapDataMatch[1].trim());
                } catch (e) {
                    console.error('Failed to parse map data:', e);
                    showError('Invalid map data format');
                    return;
                }
            } else {
                console.error('No map data found');
                showError('No map data found');
                return;
            }
        }
        
        // Set default map options
        const defaultOptions = {
            center: [37.7749, -122.4194], // Default to San Francisco
            zoom: 13,
            minZoom: 3,
            maxZoom: 18
        };
        
        // Merge with custom options if provided
        const mapOptions = mapData.options ? { ...defaultOptions, ...mapData.options } : defaultOptions;
        
        // Initialize the map
        const map = L.map('map', mapOptions);
        
        // Add tile layer (base map)
        const tileLayerUrl = mapData.tileLayer?.url || 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png';
        const tileLayerOptions = mapData.tileLayer?.options || {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
            subdomains: 'abcd',
            maxZoom: 20
        };
        
        L.tileLayer(tileLayerUrl, tileLayerOptions).addTo(map);
        
        // Process map elements if they exist
        if (mapData) {
            // Process markers
            if (mapData.markers && Array.isArray(mapData.markers)) {
                mapData.markers.forEach(marker => {
                    if (marker.position && Array.isArray(marker.position) && marker.position.length === 2) {
                        const options = marker.options || {};
                        
                        // Create marker
                        const m = L.marker(marker.position, options).addTo(map);
                        
                        // Add popup if specified
                        if (marker.popup) {
                            m.bindPopup(marker.popup);
                        }
                        
                        // Add tooltip if specified
                        if (marker.tooltip) {
                            m.bindTooltip(marker.tooltip);
                        }
                    }
                });
            }
            
            // Process polylines
            if (mapData.polylines && Array.isArray(mapData.polylines)) {
                mapData.polylines.forEach(polyline => {
                    if (polyline.points && Array.isArray(polyline.points) && polyline.points.length >= 2) {
                        const options = polyline.options || {};
                        L.polyline(polyline.points, options).addTo(map);
                    }
                });
            }
            
            // Process polygons
            if (mapData.polygons && Array.isArray(mapData.polygons)) {
                mapData.polygons.forEach(polygon => {
                    if (polygon.points && Array.isArray(polygon.points) && polygon.points.length >= 3) {
                        const options = polygon.options || {};
                        L.polygon(polygon.points, options).addTo(map);
                    }
                });
            }
            
            // Process circles
            if (mapData.circles && Array.isArray(mapData.circles)) {
              mapData.circles.forEach(circle => {
                if (circle.center && Array.isArray(circle.center) && circle.center.length === 2 && circle.radius) {
                  const options = circle.options || {};
                  L.circle(circle.center, { radius: circle.radius, ...options }).addTo(map);
                }
              });
            }
            
            // Process rectangles
            if (mapData.rectangles && Array.isArray(mapData.rectangles)) {
                mapData.rectangles.forEach(rectangle => {
                    if (rectangle.bounds && Array.isArray(rectangle.bounds) && rectangle.bounds.length === 2 &&
                        Array.isArray(rectangle.bounds[0]) && rectangle.bounds[0].length === 2 &&
                        Array.isArray(rectangle.bounds[1]) && rectangle.bounds[1].length === 2) {
                        const options = rectangle.options || {};
                        L.rectangle(rectangle.bounds, options).addTo(map);
                    }
                });
            }
            
            // Process GeoJSON
            if (mapData.geoJSON) {
                L.geoJSON(mapData.geoJSON, mapData.geoJSONOptions || {}).addTo(map);
            }
        }
    }
    
    function showError(message) {
        const mapContainer = document.getElementById('map');
        mapContainer.innerHTML = `
            <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #ff5555; text-align: center; padding: 20px;">
                <div>
                    <h2>Map Error</h2>
                    <p>${message}</p>
                </div>
            </div>
        `;
    }
</script>

