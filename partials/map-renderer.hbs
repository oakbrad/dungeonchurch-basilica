{{!-- Map Renderer Partial - A reusable component for rendering Leaflet maps --}}

<style>
    /* Match map style to Ghost */
    #map {
        background-color: var(--color-darkmode);
        flex: 1 !important;
        height: calc(100vh - 88px) !important;/* Adjust header height if needed */
        width: 100% !important;
        z-index: 1;
    }

    /* When in embed mode, make map full height */
    .embed-mode #map {
        height: 100vh !important;
    }

    /* Hide header in embed mode */
    .embed-mode .gh-head {
        display: none !important;
    }

    /* Adjust body padding in embed mode */
    .embed-mode .site-content {
        padding-top: 0 !important;
    }

    /* Hide subscription buttons in embed mode */
    .embed-mode .gh-portal-triggerbtn-iframe {
        display: none !important;
    }

    .leaflet-overlay-pane video {
      z-index: 1 !important;
    }

    /* Hide picture-in-picture button */
    .leaflet-overlay-pane video::-webkit-media-controls-picture-in-picture-button {
      display: none !important;
    }
    
    /* For Firefox */
    .leaflet-overlay-pane video::-moz-picture-in-picture-button {
      display: none !important;
    }

    /* Leaflet tooltip styling */
    .leaflet-tooltip {
        background-color: rgba(21, 23, 26, 0.9) !important;
        color: #fff !important;
        font-family: var(--font-sans) !important;
        font-size: 2em !important;
        padding: 8px 12px !important;
        border: 1px solid rgba(255, 255, 255, 0.5) !important;
        border-radius: 4px !important;
        box-shadow: 0 0 15px rgba(0, 0, 0, 0.4) !important;
        backdrop-filter: blur(8px) !important;
        -webkit-backdrop-filter: blur(8px) !important;
        width: 400px !important;
        white-space: normal !important;
    }
    .leaflet-tooltip b {
      text-transform: uppercase !important;
      font-weight: bolder !important;
      color: var(--ghost-accent-color) !important;
    }
    /* Tooltip arrow styling */
    .leaflet-tooltip-top:before,
    .leaflet-tooltip-bottom:before,
    .leaflet-tooltip-left:before,
    .leaflet-tooltip-right:before {
        border-color: transparent;
    }
    
    .leaflet-tooltip-bottom:before {
        border-bottom-color: var(--ghost-accent-color) !important;
    }
    
    .leaflet-tooltip-top:before {
        border-top-color: var(--ghost-accent-color) !important;
    }
    
    .leaflet-tooltip-left:before {
        border-left-color: var(--ghost-accent-color) !important;
    }
    
    .leaflet-tooltip-right:before {
        border-right-color: var(--ghost-accent-color) !important;
    }

    /* Leaflet popup styling */
    .leaflet-popup-content-wrapper {
        background-color: rgba(21, 23, 26, 0.9)  !important;
        border-left: 4px solid var(--ghost-accent-color)  !important;
        color: #fff  !important;
        font-family: var(--font-sans)  !important;
        border-radius: 4px  !important;
        box-shadow: 0 0 20px rgba(0, 0, 0, 0.5)  !important;
        backdrop-filter: blur(20px)  !important;
        -webkit-backdrop-filter: blur(20px)  !important;
    }

    .leaflet-popup-content {
        color: #fff !important;
        margin: 12px  !important;
    }

    /* Mobile adjustments */
    @media only screen and (max-width: 768px) {
        /* Mobile tooltip adjustments */
        .leaflet-tooltip {
            width: auto !important;
            padding: 6px 10px !important;
            white-space: normal !important;
        }
    }

    /* Map data container - hidden by default */
    .map-data-container {
        display: none;
    }
</style>

{{!-- Map container --}}
<article class="post-full leaflet-map-template">
    <div id="map" style="height: 100vh;"></div>
</article>

{{!-- Map data container - hidden, will be populated by the parent template --}}
<div id="map-data" class="map-data-container" style="display: none;">{{mapData}}</div>

{{!-- Load Leaflet dependencies if not already loaded --}}
{{#unless skipLeafletLoad}}
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="{{asset "js/leaflet-custom-icons.js"}}"></script>
{{/unless}}

<script>
document.addEventListener("DOMContentLoaded", function () {
    // Get parameters from the parent template
    const imageUrl = "{{imageUrl}}";
    const videoUrl = "{{videoUrl}}";
    const isEmbedMode = {{isEmbedMode}};
    
    // If in embed mode, add the embed-mode class to the body
    if (isEmbedMode) {
        document.body.classList.add('embed-mode');
    }
    
    // Initialize the map only if the map element exists
    const mapElement = document.getElementById('map');
    if (!mapElement) return;

    const img = new Image();
    img.onload = function () {
        const w = this.naturalWidth;
        const h = this.naturalHeight;

        // Full image bounds
        const imageBounds = [[0, 0], [h, w]];

        // Create the map
        const map = L.map("map", {
            crs: L.CRS.Simple,
            preferCanvas: true,
            minZoom: -5,
            maxZoom: 2,
            zoomSnap: 0,
            zoomDelta: 0.25,
            maxBounds: imageBounds
        });

        // Add the image
        L.imageOverlay(imageUrl, imageBounds).addTo(map);
        
        // Add video overlay (ie. clouds) if videoUrl is provided
        if (videoUrl) {
            const videoOverlay = L.videoOverlay(videoUrl, imageBounds, {
                autoplay: true,
                loop: true,
                muted: true,
                opacity: 0.6,
                keepAspectRatio: false
            }).addTo(map);
            
            // Function to disable picture-in-picture
            function disablePiP() {
                try {
                    const videoElement = videoOverlay.getElement();
                    if (videoElement) {
                        // Set the attribute
                        videoElement.disablePictureInPicture = true;
                        
                        // Also add the attribute directly to the DOM element
                        videoElement.setAttribute('disablePictureInPicture', '');
                    }
                } catch (e) {
                    console.error("Error disabling picture-in-picture:", e);
                }
            }
            
            // Try immediately
            disablePiP();
            
            // Also try after a short delay to ensure the video is loaded
            setTimeout(disablePiP, 100);
        }
        
        // Get viewport height and calculate scale to fit height
        const viewportHeight = window.innerHeight;
        const scale = viewportHeight / h;
        const zoom = Math.log2(scale);

        // Clamp to allowed zooms
        const clampedZoom = Math.max(map.getMinZoom(), Math.min(map.getMaxZoom(), zoom));

        map.setView([h / 2, w / 2], clampedZoom);
        
        // Process map data from post content
        processMapData(map, h, w);
    };

    img.src = imageUrl;
    
    /**
     * Process map data from post content
     * Looks for JSON data in the post content and adds markers and other overlays to the map
     */
    function processMapData(map, imageHeight, imageWidth) {
        // Get the map data container
        const mapDataContainer = document.getElementById('map-data');
        if (!mapDataContainer) return;
        
        try {
            // Create a temporary div to parse the HTML content
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = mapDataContainer.innerHTML;
            
            // Find all pre elements that might contain JSON data
            const preElements = tempDiv.querySelectorAll('pre');
            
            if (preElements.length === 0) {
                console.log('No pre elements found in map data container. Raw content:', mapDataContainer.innerHTML);
                
                // Try to find JSON directly in the content
                const content = mapDataContainer.innerHTML.trim();
                if (content && (content.startsWith('{') || content.startsWith('['))) {
                    try {
                        const mapData = JSON.parse(content);
                        processMapData(mapData, map);
                        return;
                    } catch (e) {
                        console.error('Error parsing direct JSON content:', e);
                    }
                }
            } else {
                // Process each pre element
                preElements.forEach(pre => {
                    try {
                        // Try to parse the content as JSON
                        const content = pre.textContent.trim();
                        if (!content.startsWith('{') && !content.startsWith('[')) return;
                        
                        const mapData = JSON.parse(content);
                        processMapData(mapData, map);
                    } catch (e) {
                        console.error('Error parsing map data JSON from pre element:', e);
                    }
                });
            }
        } catch (e) {
            console.error('Error processing map data:', e);
        }
    }
    
    /**
     * Process the map data object and add overlays to the map
     */
    function processMapData(mapData, map) {
        if (!mapData) return;
        
        // Process markers
        if (mapData.markers && Array.isArray(mapData.markers)) {
            mapData.markers.forEach(marker => {
                if (marker.position && Array.isArray(marker.position) && marker.position.length === 2) {
                    // Convert coordinates to match the image coordinate system if needed
                    const y = marker.position[0];
                    const x = marker.position[1];
                    
                    let markerOptions = {};
                    
                    // Apply custom icon if specified
                    if (marker.icon) {
                        markerOptions.icon = L.icon(marker.icon);
                    } else if (marker.iconType && window.customIcons && window.customIcons[marker.iconType]) {
                        // Use predefined custom icon if iconType is specified
                        markerOptions.icon = window.customIcons[marker.iconType];
                    }
                    
                    // Create the marker
                    const m = L.marker([y, x], markerOptions).addTo(map);
                    
                    // Add popup if specified
                    if (marker.popup) {
                        m.bindPopup(marker.popup);
                    }
                    
                    // Add tooltip if specified
                    if (marker.tooltip) {
                        m.bindTooltip(marker.tooltip);
                    }
                }
            });
        }
        
        // Process polylines
        if (mapData.polylines && Array.isArray(mapData.polylines)) {
            mapData.polylines.forEach(polyline => {
                if (polyline.points && Array.isArray(polyline.points)) {
                    const options = polyline.options || {};
                    L.polyline(polyline.points, options).addTo(map);
                }
            });
        }
        
        // Process polygons
        if (mapData.polygons && Array.isArray(mapData.polygons)) {
            mapData.polygons.forEach(polygon => {
                if (polygon.points && Array.isArray(polygon.points)) {
                    const options = polygon.options || {};
                    L.polygon(polygon.points, options).addTo(map);
                }
            });
        }
        
        // Process circles
        if (mapData.circles && Array.isArray(mapData.circles)) {
            mapData.circles.forEach(circle => {
                if (circle.center && Array.isArray(circle.center) && circle.center.length === 2 && circle.radius) {
                    const options = circle.options || {};
                    L.circle(circle.center, { radius: circle.radius, ...options }).addTo(map);
                }
            });
        }
        
        // Process rectangles
        if (mapData.rectangles && Array.isArray(mapData.rectangles)) {
            mapData.rectangles.forEach(rectangle => {
                if (rectangle.bounds && Array.isArray(rectangle.bounds) && rectangle.bounds.length === 2) {
                    const options = rectangle.options || {};
                    L.rectangle(rectangle.bounds, options).addTo(map);
                }
            });
        }
        
        // Process custom view settings
        if (mapData.view) {
            if (mapData.view.center && Array.isArray(mapData.view.center) && mapData.view.center.length === 2) {
                const zoom = mapData.view.zoom !== undefined ? mapData.view.zoom : map.getZoom();
                map.setView(mapData.view.center, zoom);
            }
        }
    }
});
</script>
