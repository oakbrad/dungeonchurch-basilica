<!-- style overrides for Leaflet -->
<link rel="stylesheet" href="{{asset 'map.css'}}">
<!-- Leaflet CSS -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">

<!-- Custom styles for video overlay -->
<style>
  .leaflet-image-layer.leaflet-interactive.leaflet-video-layer {
    z-index: 400 !important;
    visibility: visible !important;
    display: block !important;
  }
  
  .leaflet-video-layer video {
    object-fit: cover !important;
    width: 100% !important;
    height: 100% !important;
    visibility: visible !important;
    display: block !important;
  }
</style>

<!-- MAP CONTAINTER -->
        <article class="post-full leaflet-map-template">
            <div id="map" style="height: 100vh;"></div>
            <div class="map-data-container">{{content}}</div>
        </article>


<!-- Leaflet Script -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="{{asset "js/leaflet-custom-icons.js"}}"></script>

<script>
document.addEventListener("DOMContentLoaded", function () {
  // Only initialize the map if the map element exists
  // (it won't exist for members/paid content if the user doesn't have access)
  const mapElement = document.getElementById('map');
  if (!mapElement) return;

  const imageUrl = "{{feature_image}}";
  
  // Get video overlay from meta tag if it exists
  const overlayMeta = document.querySelector('meta[name="custom:overlay"]');
  const overlayFileName = overlayMeta ? overlayMeta.getAttribute('content') : null;
  const videoUrl = overlayFileName ? `/assets/images/overlays/${overlayFileName}` : null;
  
  // Get opacity from meta tag if it exists, otherwise default to 0.6
  const opacityMeta = document.querySelector('meta[name="custom:opacity"]');
  const opacity = opacityMeta ? parseFloat(opacityMeta.getAttribute('content')) : 0.6;

  const img = new Image();
  img.onload = function () {
    const w = this.naturalWidth;
    const h = this.naturalHeight;

    // Full image bounds
    const imageBounds = [[0, 0], [h, w]];

    // Create the map
    const map = L.map("map", {
      crs: L.CRS.Simple,
      preferCanvas: true,
      minZoom: -5,
      maxZoom: 2,
      zoomSnap: 0,
      zoomDelta: 0.25,
      maxBounds: imageBounds
    });

    // Add the image
    L.imageOverlay(imageUrl, imageBounds).addTo(map);
    
    // Add video overlay (ie. clouds) only if videoUrl exists
    let videoOverlay = null;
    if (videoUrl) {
      // Create a video element first to have more control
      const videoElement = document.createElement('video');
      videoElement.autoplay = true;
      videoElement.loop = true;
      videoElement.muted = true;
      videoElement.style.objectFit = 'cover';
      videoElement.style.width = '100%';
      videoElement.style.height = '100%';
      videoElement.style.display = 'block';
      videoElement.style.visibility = 'visible';
      videoElement.disablePictureInPicture = true;
      videoElement.setAttribute('disablePictureInPicture', '');
      videoElement.src = videoUrl;
      
      // Create the video overlay with our prepared video element
      videoOverlay = L.videoOverlay(videoElement, imageBounds, {
        opacity: opacity,
        keepAspectRatio: true,
        interactive: true
      }).addTo(map);
      
      // Add a class to the video overlay container for CSS targeting
      videoOverlay.getElement().parentNode.classList.add('leaflet-video-layer');
    }
    
    // Get viewport height and calculate scale to fit height
    const viewportHeight = window.innerHeight;
    const scale = viewportHeight / h;
    const zoom = Math.log2(scale);

    // Clamp to allowed zooms
    const clampedZoom = Math.max(map.getMinZoom(), Math.min(map.getMaxZoom(), zoom));

    map.setView([h / 2, w / 2], clampedZoom);
    
    // Force map redraw after a short delay to ensure everything is loaded
    setTimeout(function() {
      map.invalidateSize();
      
      // If we have a video overlay, make sure it's visible
      if (videoOverlay) {
        const videoElement = videoOverlay.getElement();
        if (videoElement) {
          // Force video to be visible
          videoElement.style.display = 'block';
          videoElement.style.visibility = 'visible';
          videoElement.style.objectFit = 'cover';
          videoElement.style.width = '100%';
          videoElement.style.height = '100%';
          
          // Force parent container to be visible
          const container = videoElement.parentNode;
          if (container) {
            container.style.display = 'block';
            container.style.visibility = 'visible';
            container.style.zIndex = '400';
          }
        }
      }
    }, 100);
    
    // Process map data from post content
    processMapData(map, h, w);
  };

  img.src = imageUrl;
  
  /**
   * Process map data from post content
   * Looks for JSON data in the post content and adds markers and other overlays to the map
   */
  function processMapData(map, imageHeight, imageWidth) {
    const mapDataContainer = document.querySelector('.map-data-container');
    if (!mapDataContainer) return;
    
    try {
      // Find all pre elements that might contain JSON data
      const preElements = mapDataContainer.querySelectorAll('pre');
      
      preElements.forEach(pre => {
        try {
          // Try to parse the content as JSON
          const content = pre.textContent.trim();
          if (!content.startsWith('{') && !content.startsWith('[')) return;
          
          const mapData = JSON.parse(content);
          
          // Process the map data
          if (mapData) {
            // Process markers
            if (mapData.markers && Array.isArray(mapData.markers)) {
              mapData.markers.forEach(marker => {
                if (marker.position && Array.isArray(marker.position) && marker.position.length === 2) {
                  // Convert coordinates to match the image coordinate system if needed
                  const y = marker.position[0];
                  const x = marker.position[1];
                  
                  let markerOptions = {};
                  
                  // Apply custom icon if specified
                  if (marker.icon) {
                    markerOptions.icon = L.icon(marker.icon);
                  } else if (marker.iconType && window.customIcons && window.customIcons[marker.iconType]) {
                    // Use predefined custom icon if iconType is specified
                    markerOptions.icon = window.customIcons[marker.iconType];
                  }
                  
                  // Create the marker
                  const m = L.marker([y, x], markerOptions).addTo(map);
                  
                  // Add popup if specified
                  if (marker.popup) {
                    m.bindPopup(marker.popup);
                  }
                  
                  // Add tooltip if specified
                  if (marker.tooltip) {
                    m.bindTooltip(marker.tooltip);
                  }
                }
              });
            }
            
            // Process polylines
            if (mapData.polylines && Array.isArray(mapData.polylines)) {
              mapData.polylines.forEach(polyline => {
                if (polyline.points && Array.isArray(polyline.points)) {
                  const options = polyline.options || {};
                  L.polyline(polyline.points, options).addTo(map);
                }
              });
            }
            
            // Process polygons
            if (mapData.polygons && Array.isArray(mapData.polygons)) {
              mapData.polygons.forEach(polygon => {
                if (polygon.points && Array.isArray(polygon.points)) {
                  const options = polygon.options || {};
                  L.polygon(polygon.points, options).addTo(map);
                }
              });
            }
            
            // Process circles
            if (mapData.circles && Array.isArray(mapData.circles)) {
              mapData.circles.forEach(circle => {
                if (circle.center && Array.isArray(circle.center) && circle.center.length === 2 && circle.radius) {
                  const options = circle.options || {};
                  L.circle(circle.center, { radius: circle.radius, ...options }).addTo(map);
                }
              });
            }
            
            // Process rectangles
            if (mapData.rectangles && Array.isArray(mapData.rectangles)) {
              mapData.rectangles.forEach(rectangle => {
                if (rectangle.bounds && Array.isArray(rectangle.bounds) && rectangle.bounds.length === 2) {
                  const options = rectangle.options || {};
                  L.rectangle(rectangle.bounds, options).addTo(map);
                }
              });
            }
            
            // Process custom view settings
            if (mapData.view) {
              if (mapData.view.center && Array.isArray(mapData.view.center) && mapData.view.center.length === 2) {
                const zoom = mapData.view.zoom !== undefined ? mapData.view.zoom : map.getZoom();
                map.setView(mapData.view.center, zoom);
              }
            }
          }
        } catch (e) {
          console.error('Error parsing map data JSON:', e);
        }
      });
    } catch (e) {
      console.error('Error processing map data:', e);
    }
  }
});

// Enable debug info with a query parameter
if (window.location.search.includes('debug=true')) {
  document.querySelector('.debug-info').style.display = 'block';
}
</script>
